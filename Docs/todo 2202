
Gurobi solução inicial para aproveitar a solução anterior. Solução de entrada. Start solution

Gerar uma solução heurística com o ig, depois pegar os dados e jogar no gurobi

Construtivo: Priorizar os obrigatorios (SERA?)

------------------------------------------
Como é melhor aprimorante, ja é suficiente para ignorar a inconsistencia Se for locker locker tentar juntar
analizar somatório de clientes por locker

Deixar repetir locker no inter, o intra vai fundir. Vai ter que mudar 

----------------------------------------------

TODO: Testar varredura das buscas locais, pra ver se fazerm sentido
Lembrar da questão de interseções de movimentos entre buscas

Checklist de reavaliação das buscas:
    Índices de troca: OK



seq_a_1 = &this->solution->routes.at(coordinates[0])->sequences.at(coordinates[1]);
seq_a_2 = &this->solution->routes.at(coordinates[0])->sequences.at(coordinates[1]+1);
seq_b = &this->solution->routes.at(coordinates[2])->sequences.at(coordinates[3]);
cout<<seq_a_1->node->id<<","<<seq_a_2->node->id<<","<<coordinates[0]<<
" - "<<seq_b->node->id<<","<<coordinates[2]<<" - "<<best_delta<<endl;

Verificar por que alguns deltas do reduce de lockers são positivos